ë¬¸ì œì˜ í•µì‹¬ì€ ë¼ìš°íŒ… ì¶©ëŒ + ë¼ìš°í„° í˜¼ìš©(wouter vs react-router) + ì¿¼ë¦¬/ë Œë” ë¡œì§ ë¯¸ìŠ¤ë§¤ì¹˜ì…ë‹ˆë‹¤. ì•„ë˜ ìˆœì„œëŒ€ë¡œ ê³ ì¹˜ë©´ isReadOnlyê°€ ì •ìƒì ìœ¼ë¡œ trueë¡œ ì „ë‹¬ë˜ê³ , ì½ê¸°ì „ìš© ìº”ë²„ìŠ¤ì˜ ë…¸ë“œê°€ ë°”ë¡œ ë Œë”ë§ë©ë‹ˆë‹¤.

1) ë¼ìš°í„° í˜¼ìš© ê¸ˆì§€: wouter â†’ react-routerë¡œ í†µì¼

ReadOnlyCanvas.tsxì—ì„œ wouterì˜ useRouteë¥¼ ì“°ë©´, ìƒìœ„ê°€ react-routerì¼ ë•Œ í•­ìƒ ë§¤ì¹­ ì‹¤íŒ¨í•©ë‹ˆë‹¤. ê²°ê³¼ì ìœ¼ë¡œ canvasIdê°€ undefined â†’ enabled:falseë¡œ ì¿¼ë¦¬ê°€ ì•ˆ ë•ë‹ˆë‹¤.
useRoute ì œê±°í•˜ê³  react-routerì˜ useParamsë¡œ êµì²´í•˜ì„¸ìš”.

// ReadOnlyCanvas.tsx
import { useParams } from "react-router-dom";
import { useQuery } from "@tanstack/react-query";

type Params = { canvasId: string };

export default function ReadOnlyCanvas() {
  const { canvasId } = useParams<Params>();

  const { data: canvas } = useQuery({
    queryKey: ['/api/public/canvas', canvasId],
    enabled: !!canvasId,
    queryFn: async () => {
      const res = await fetch(`/api/public/canvas/${canvasId}`);
      if (!res.ok) throw new Error('Failed to fetch canvas');
      return res.json();
    },
  });

  const { data: canvasState } = useQuery({
    queryKey: ['/api/public/canvas', canvasId, 'state'],
    enabled: !!canvasId,
    queryFn: async () => {
      const res = await fetch(`/api/public/canvas/${canvasId}/state`);
      if (!res.ok) throw new Error('Failed to fetch canvas state');
      return res.json();
    },
  });

  return (
    <div className="min-h-screen bg-gray-50">
      <div className="flex-1">
        <CanvasArea
          canvas={canvas}
          canvasState={canvasState}
          onNodeSelect={() => {}}
          selectedNodeId={null}
          isReadOnly={true}
          externalMemos={[]}
        />
      </div>
    </div>
  );
}


ì¶”ê°€ í¬ì¸íŠ¸: ê¸°ì¡´ ì½”ë“œì—” queryFnì´ ì—†ì—ˆìŠµë‹ˆë‹¤. TanStack Query(v4/v5)ì—ì„œëŠ” ê¸°ë³¸ fetcherê°€ ì—†ìœ¼ë‹ˆ ë°˜ë“œì‹œ ë„£ì–´ì£¼ì„¸ìš”.

2) ë¼ìš°íŒ… ìš°ì„ ìˆœìœ„/ë§¤ì¹­ ì •ì •: exactì™€ ë³´í˜¸ ë¼ìš°íŠ¸ ë¶„ë¦¬

path="/"ê°€ exact ì—†ì´ ìˆìœ¼ë©´ ë¬´ì—‡ì´ë“  ë§¤ì¹­ë©ë‹ˆë‹¤. ê°€ë” ìƒíƒœ ë³€í™”(ë¡œê·¸ì¸ ìƒíƒœ í† ê¸€) ì¤‘ì— /share/...ë³´ë‹¤ ë¨¼ì € ì¡íˆë©´ì„œ ì¼ë°˜ Canvas/Home ê²½ë¡œê°€ ë Œë”ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ì²˜ëŸ¼ exactë¥¼ ë¶™ì´ê³ , í¼ë¸”ë¦­/ë³´í˜¸ ë¼ìš°íŠ¸ë¥¼ ëª…í™•íˆ ë¶„ë¦¬í•˜ì„¸ìš”.

// App.tsx (Router)
import { Switch, Route, Redirect } from "react-router-dom";

function Router() {
  const { isAuthenticated, isLoading } = useAuth();

  return (
    <Switch>
      {/* 1) í¼ë¸”ë¦­: ë°˜ë“œì‹œ ìµœìƒë‹¨ + exact */}
      <Route exact path="/share/:canvasId" component={ReadOnlyCanvas} />

      {/* 2) ë³´í˜¸ ë¼ìš°íŠ¸: ë³„ë„ ê²Œì´íŠ¸ */}
      {!isLoading && isAuthenticated && (
        <>
          <Route exact path="/" component={Home} />
          <Route exact path="/canvas/:canvasId" component={Canvas} />
          <Route exact path="/admin" component={Admin} />
        </>
      )}

      {/* 3) ë¡œë”©/ë¹„ë¡œê·¸ì¸: ëœë”©ìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸(shareëŠ” ì˜ˆì™¸ë¡œ ì´ë¯¸ ì²˜ë¦¬ë¨) */}
      {(!isAuthenticated || isLoading) && (
        <>
          <Route exact path="/" component={Landing} />
          <Redirect to="/" />
        </>
      )}

      <Route component={NotFound} />
    </Switch>
  );
}


í•µì‹¬: /share/:canvasIdê°€ í•­ìƒ ë¨¼ì € ë§¤ì¹­ë˜ê³ , / ë¼ìš°íŠ¸ë“¤ì€ exactë¡œ ì œí•œí•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•´ì•¼ ReadOnlyCanvasê°€ í™•ì‹¤íˆ ë Œë”ë©ë‹ˆë‹¤.

3) CanvasAreaì—ì„œ ì½ê¸°ì „ìš© ê²½ë¡œë¥¼ í™•ì •ì ìœ¼ë¡œ ì‚¬ìš©

finalNodesê°€ ì •ì˜ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ìƒíƒœ ì „ê°œ ìˆœì„œìƒ undefinedì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì½ê¸°ì „ìš©ì—ì„  ì„œë²„ê°€ ì¤€ flowJson.nodesë§Œ ì“°ë„ë¡ ê³ ì •í•˜ê³ , ì¢Œí‘œ ì•ˆì „ê°€ë“œë„ í¬í•¨í•˜ì„¸ìš”.

// CanvasArea.tsx
import { useMemo } from "react";

export default function CanvasArea({
  canvasState,
  isReadOnly = false,
  // ... ìƒëµ
}: CanvasAreaProps) {
  const flowData = (canvasState?.flowJson as any) || { nodes: [], edges: [] };

  const renderNodes = useMemo(() => {
    const srcNodes = isReadOnly ? (flowData?.nodes ?? []) : (flowData?.nodes ?? []);
    // ì½ê¸°ì „ìš©ì—ì„œëŠ” ì„œë²„ ì¢Œí‘œ ê·¸ëŒ€ë¡œ(ì—†ëŠ” ê²½ìš°ë§Œ ìµœì†Œê°’)
    return (srcNodes || []).map((node: any) => ({
      ...node,
      position: {
        x: Number.isFinite(node?.position?.x) ? node.position.x : 50,
        y: Number.isFinite(node?.position?.y) ? node.position.y : 50,
      },
      draggable: false,
      selectable: false,
    }));
  }, [isReadOnly, flowData]);

  return (
    <div className="canvas-content">
      {renderNodes.map((node: any, i: number) => {
        // ë””ë²„ê·¸: ì½ê¸°ì „ìš©ì´ ë°˜ë“œì‹œ trueì—¬ì•¼ í•¨
        // console.log('ğŸ¯ node', i, node.id, { isReadOnly });
        return (
          <FunnelNode
            key={node.id ?? i}
            node={node}
            isReadOnly={isReadOnly}
          />
        );
      })}
    </div>
  );
}


ìš”ì§€: ì½ê¸°ì „ìš©ì—ì„  ë¡œì»¬ ìƒíƒœë‚˜ í¸ì§‘ íŒŒì´í”„ë¼ì¸ì„ ì „í˜€ íƒ€ì§€ ì•Šê²Œ ê³ ì •í•©ë‹ˆë‹¤.

4) ì„œë²„ ê³µê°œ API ê²½ë¡œ ì¼ì¹˜ í™•ì¸

í”„ë¡ íŠ¸ì—ì„œ í˜¸ì¶œí•˜ëŠ” ê²½ë¡œì™€ ì„œë²„ ë¼ìš°íŠ¸ê°€ 1:1ë¡œ ì¼ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤. ì•ì„œ queryFnì—ì„œ /api/public/canvas/${canvasId}ì™€ /api/public/canvas/${canvasId}/stateë¥¼ í˜¸ì¶œí–ˆìœ¼ë‹ˆ, ì„œë²„ë„ ë™ì¼í•œ ë¼ìš°íŠ¸ë¥¼ ë…¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.

// server/routes.ts (public)
app.get('/api/public/canvas/:canvasId', async (req, res) => {
  try {
    const { canvasId } = req.params;
    const canvas = await storage.getCanvas(canvasId);
    if (!canvas) return res.status(404).json({ message: "Canvas not found" });
    res.json(canvas);
  } catch (e) {
    console.error(e);
    res.status(500).json({ message: "Failed to fetch canvas" });
  }
});

app.get('/api/public/canvas/:canvasId/state', async (req, res) => {
  try {
    const { canvasId } = req.params;
    const canvas = await storage.getCanvas(canvasId);
    if (!canvas) return res.status(404).json({ message: "Canvas not found" });

    const canvasState = await storage.getLatestCanvasState(canvasId);
    if (!canvasState) return res.json({ flowJson: { nodes: [], edges: [] } });
    res.json(canvasState);
  } catch (error) {
    console.error("Error fetching public canvas state:", error);
    res.status(500).json({ message: "Failed to fetch canvas state" });
  }
});

5) í”í•œ í•¨ì • ì ê²€ ì²´í¬ë¦¬ìŠ¤íŠ¸

 /share/:canvasIdì— exact ë¶™ì˜€ëŠ”ê°€?

 **useRoute(wouter) â†’ useParams(react-router)**ë¡œ êµì²´í–ˆëŠ”ê°€?

 TanStack Queryì— **queryFn**ì„ ë„£ì—ˆëŠ”ê°€?

 ì½ê¸°ì „ìš© ê²½ë¡œì—ì„œ **ë¡œì»¬ í¸ì§‘ ìƒíƒœ/finalNodes**ë¥¼ ì°¸ì¡°í•˜ì§€ ì•ŠëŠ”ê°€?

 FunnelNode ë‚´ë¶€ì—ì„œ ë“œë˜ê·¸/ì„ íƒì„ props.isReadOnlyë¡œ ì°¨ë‹¨í•˜ëŠ”ê°€?

 ì„œë²„ ê³µê°œ ì—”ë“œí¬ì¸íŠ¸ ê²½ë¡œê°€ í”„ë¡ íŠ¸ì™€ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ê°€?