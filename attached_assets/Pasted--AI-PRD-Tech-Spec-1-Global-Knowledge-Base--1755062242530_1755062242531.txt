📌 두더지 AI — 퍼널 캔버스 PRD & Tech Spec (최종)

1. 기본 지식베이스 (Global Knowledge Base)

역할: 모든 사용자에게 공통 제공되는 세일즈·퍼널 설계 전문 지식 저장소

DB 테이블: global_ai_knowledge

id: 고유 ID

title: 자료 제목

content: 전처리·벡터화된 텍스트

tags: 예) "세일즈 원칙", "퍼널 전략"

source_url: 참고 링크(선택)

version: 버전 관리

업로드 권한: 관리자 전용 (대시보드 업로드)

활용 시점: AI 피드백, 템플릿 생성, 노드 추천 시 항상 참조

2. 개별 지식베이스 (User Knowledge Base)

역할: 크리에이터별 업로드 자료 저장소

DB 테이블: user_ai_knowledge

id, user_id, asset_type(pdf/url/video/text), asset_title, asset_content, tags, source_url, created_at

업로드 경로: 좌측 사이드바 → "지식 업로드"

활용 시점: 해당 사용자 퍼널 설계/AI 피드백 시 Global KB와 함께 컨텍스트로 통합

PDF 처리: 텍스트 PDF vs 스캔 PDF 자동 감지 → 스캔 PDF는 OpenAI API OCR 처리

3. 퍼널 캔버스 구조

좌측 사이드바: 자료 업로드, 업로드 내역 리스트, 템플릿 불러오기

중앙 화이트보드: 피그마/메이크닷컴 스타일 드래그앤드롭 UI

노드(아이콘): 이메일, 문자 CRM, 랜딩페이지 등 + 하위 개념(속성·콘텐츠·지표) 설정 가능

우측 패널: 노드 선택 시 3개 탭 표시

속성(Properties): 채널, CTA, 설정 값

콘텐츠(Contents): 이메일 제목/본문, VSL 스크립트 등

지표(Metrics): CTR, 오픈율, 클릭 수, 발송량 (기간 필터)

4. AI 피드백 로직

트리거: 우측 하단 플로팅 버튼 또는 Cmd/Ctrl + /

서버 처리:

현재 퍼널 flow_json

Global KB Top-K 문서

User KB Top-K 문서

OpenAI API 호출 → JSON 응답:

[
  {
    "nodeId": "string",
    "suggestion": "string",
    "severity": "low|medium|high",
    "rationale": "string"
  }
]

UI 반영: 노드별 뱃지·툴팁 표시

5. 템플릿 시스템

구성: 사전 제작 템플릿을 Global DB에 저장, 누구나 import·수정 가능

DB 테이블: funnel_templates

id, title, description, flow_json, tags, created_by, is_global

사용 흐름: 템플릿 선택 → 현재 보드에 import → 필요 시 수정 후 저장

6. 관리 전략

Global KB: 최신 세일즈/퍼널 전략, 마케팅 지표 기준 정기 업데이트

User KB: 업로드 시 자동 전처리·태그화

AI 품질 유지: 버전·태그 기반 검색, 중복 문서 관리

이 구조로 가면 **전문가 지식(기본)**과 사용자 맞춤 지식을 완전히 분리·통합 적용 가능하며, 템플릿과 노드 확장성까지 확보됩니다.



🚀 Replit Handoff — 최종 체크리스트 & 사양

이 절을 그대로 Replit 개발/배포에 사용하십시오. (Node/Next.js + Postgres 가정)

A. 런타임 & 의존성

Node 20+, PostgreSQL 14+

NPM: express 또는 next, pg, passport, passport-google-oauth20, multer, pdf-parse, sharp, openai, zod, p-limit, uuid

선택: react-flow-renderer, dagre, pgvector(확장), bullmq(옵션)

B. ENV (Replit Secrets)

APP_ENV=dev|prod
APP_URL=https://<your-repl>.repl.co
DATABASE_URL=postgres://...
SESSION_SECRET=...
GOOGLE_CLIENT_ID=...
GOOGLE_CLIENT_SECRET=...
OAUTH_REDIRECT_URI=https://<your-repl>.repl.co/auth/google/callback
OPENAI_API_KEY=sk-...
APIFY_TOKEN=...
INTERNAL_TOKEN=<long_random>
TZ_DEFAULT=Asia/Seoul

C. 라우팅(API 핵심)

Auth

GET /auth/google → OAuth 시작

GET /auth/google/callback → 로그인 후 /app

Assets/KB

POST /api/assets (파일/URL 등록: pdf|youtube|instagram|note)

GET /api/assets/:id/status

Canvas

GET /api/canvas/:id/state/latest

POST /api/canvas/:id/state { flow_json }

Feedback

POST /api/canvas/:id/feedback { state_version } → 캐시(flow_hash/kb_hash) 검사 후 OpenAI 호출

GET /api/canvas/:id/feedback/latest

Templates

GET /api/templates?scope=public|shared|private

POST /api/templates/apply { template_id, canvas_id, parameters }

(관리) POST /api/templates / POST /api/templates/:id/versions

Node I/O

POST /api/node/:instanceId/properties { props_json }

POST /api/node/:instanceId/contents { content_type, content_text }

POST /api/node/:instanceId/metrics { metric_key, value, period_start, period_end, source }

모든 /api는 세션 인증 + 워크스페이스 권한 가드, /internal/*는 Authorization: Bearer INTERNAL_TOKEN 필수.

D. 스케줄러/잡(HTTP 호출)

5분마다: POST /internal/jobs/tick — 인제스트 큐 실행/재시도

문서요약 캐시 재생성(선택): POST /internal/kb/refresh — 변경분만

E. PDF/URL 인제스트 파이프라인 (요약 구현)

등록(파일/URL) → assets 생성 → ingest_jobs enqueue

PDF: pdf-parse 1차 추출 → 페이지별 스캔 판정 → 스캔 페이지는 sharp로 300DPI 이미지 변환 → OpenAI Vision OCR → 병합 텍스트

URL: Apify 수집(캡션/설명/메타) → 전처리

청크(800~1200자) & 임베딩(OpenAI) → asset_chunks 저장 (pgvector)

문서요약 캐시 생성 및 저장

F. 캐시 키

flow_hash = sha256(normalized(flow_json))

kb_hash = sha256(sorted(topk_asset_ids))

동일 조합이면 직전 피드백 응답 재사용(TTL 옵션)

G. 프롬프트 구성(피드백)

고정 파트: 베스트프랙티스(버전: bp_version) + 역할지시(세일즈/퍼널 전문가)

입력 파트: flow_json(간소화), 관련 자산 요약 Top‑K, 사용자 업종/목표

출력 스키마(JSON): [ { nodeId, suggestion, severity, rationale } ]

🗄 DB — 핵심 테이블 DDL (Postgres, 요약)

실제 배포 전 uuid-ossp, pgvector 확장 설치 고려.

-- 0) 확장 (선택)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS vector; -- pgvector

-- 1) 계정/워크스페이스
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT UNIQUE NOT NULL,
  google_id TEXT UNIQUE,
  name TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE workspaces (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  owner_user_id UUID REFERENCES users(id),
  name TEXT,
  plan TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE workspace_members (
  workspace_id UUID REFERENCES workspaces(id),
  user_id UUID REFERENCES users(id),
  role TEXT CHECK (role IN ('owner','admin','editor','viewer')),
  invited_at TIMESTAMPTZ DEFAULT now(),
  PRIMARY KEY (workspace_id, user_id)
);

-- 2) 캔버스/상태/피드백
CREATE TABLE canvases (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  workspace_id UUID REFERENCES workspaces(id),
  title TEXT,
  template_id UUID NULL,
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE canvas_states (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  canvas_id UUID REFERENCES canvases(id),
  version INT NOT NULL,
  flow_json JSONB NOT NULL,
  flow_hash TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX ON canvas_states (canvas_id, version DESC);
CREATE INDEX ON canvas_states (flow_hash);

CREATE TABLE feedback_runs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  canvas_id UUID REFERENCES canvases(id),
  state_version INT,
  flow_hash TEXT,
  kb_hash TEXT,
  prompt_version TEXT,
  bp_version TEXT,
  model TEXT,
  latency_ms INT,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE feedback_items (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  run_id UUID REFERENCES feedback_runs(id) ON DELETE CASCADE,
  node_id TEXT,
  severity TEXT CHECK (severity IN ('low','medium','high')),
  suggestion TEXT,
  rationale TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 3) 자산/인제스트/임베딩
CREATE TABLE assets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  workspace_id UUID REFERENCES workspaces(id),
  canvas_id UUID NULL REFERENCES canvases(id),
  type TEXT CHECK (type IN ('pdf','youtube','instagram','note')),
  url TEXT,
  file_ref TEXT,
  content_sha256 TEXT,
  title TEXT,
  meta_json JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE UNIQUE INDEX ON assets (content_sha256) WHERE content_sha256 IS NOT NULL;

CREATE TABLE asset_chunks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  asset_id UUID REFERENCES assets(id) ON DELETE CASCADE,
  seq INT,
  text TEXT,
  embedding vector(1536),
  tokens INT,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX asset_chunks_ivf ON asset_chunks USING ivfflat (embedding vector_cosine_ops);
CREATE INDEX ON asset_chunks (asset_id, seq);

CREATE TABLE ingest_jobs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  asset_id UUID REFERENCES assets(id) ON DELETE CASCADE,
  job_type TEXT CHECK (job_type IN ('apify','pdf_text','pdf_ocr')),
  status TEXT CHECK (status IN ('pending','running','succeeded','failed')),
  attempts INT DEFAULT 0,
  last_error TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- 4) 템플릿/도움말/아이콘
CREATE TABLE templates (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  owner_scope TEXT CHECK (owner_scope IN ('public','shared','private')),
  owner_workspace_id UUID NULL REFERENCES workspaces(id),
  name TEXT,
  category TEXT,
  tags TEXT[],
  current_version INT,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE template_versions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  template_id UUID REFERENCES templates(id) ON DELETE CASCADE,
  version INT,
  flow_json JSONB,
  parameters_json JSONB,
  best_practices TEXT[],
  changelog TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE help_docs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  key TEXT UNIQUE,
  title TEXT,
  html TEXT,
  asset_ref TEXT,
  owner_user_id UUID REFERENCES users(id),
  updated_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE icon_meta (
  id TEXT PRIMARY KEY,
  label TEXT,
  icon_name TEXT,
  color TEXT,
  info_doc_key TEXT REFERENCES help_docs(key),
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 5) 노드 타입/인스턴스/콘텐츠/지표
CREATE TABLE node_types (
  key TEXT PRIMARY KEY,
  label TEXT,
  category TEXT,
  default_props_json JSONB
);
CREATE TABLE node_instances (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  canvas_state_id UUID REFERENCES canvas_states(id) ON DELETE CASCADE,
  node_id_in_flow TEXT,
  node_type_key TEXT REFERENCES node_types(key),
  props_json JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE node_contents (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  node_instance_id UUID REFERENCES node_instances(id) ON DELETE CASCADE,
  content_type TEXT,
  content_text TEXT,
  version INT DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE node_metrics (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  node_instance_id UUID REFERENCES node_instances(id) ON DELETE CASCADE,
  metric_key TEXT,
  metric_value_numeric DOUBLE PRECISION,
  metric_value_text TEXT,
  period_start TIMESTAMPTZ,
  period_end TIMESTAMPTZ,
  source TEXT CHECK (source IN ('auto','manual')),
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 6) KB — Global & User
CREATE TABLE global_ai_knowledge (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title TEXT,
  content TEXT,
  tags TEXT[],
  source_url TEXT,
  version INT,
  created_at TIMESTAMPTZ DEFAULT now()
);
CREATE TABLE user_ai_knowledge (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),
  asset_type TEXT,
  asset_title TEXT,
  asset_content TEXT,
  tags TEXT[],
  source_url TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

인덱스/제약은 서비스 운영 중 쿼리 패턴에 맞춰 추가 최적화하십시오.

🔒 보안/권한

모든 엔드포인트는 세션 인증 + 워크스페이스 범위 검증

/internal/*는 헤더 토큰 필수 + IP 제한(옵션)

파일 업로드는 확장자 화이트리스트 + 사이즈 제한

URL 인제스트는 도메인 검증(허용 목록)

🧪 QA 체크 (출시 전)



🧩 코드 스니펫(개요)

// feedback controller (의사코드)
const runFeedback = async (canvasId, stateVersion, userId) => {
  const state = await getCanvasState(canvasId, stateVersion);
  const flowHash = sha256(normalize(state.flow_json));
  const kb = await getTopKKnowledge(userId, state); // Global+User KB mix
  const kbHash = sha256(kb.ids.join(','));

  const cached = await getCachedFeedback(flowHash, kbHash);
  if (cached) return cached;

  const prompt = buildPrompt({ flow: state.flow_json, kb });
  const result = await openai.responses.create({
    model: 'gpt-4.1-mini',
    input: prompt,
    response_format: { type: 'json' }
  });
  return await saveFeedback(result, { flowHash, kbHash });
};

✅ 한 줄 요약

이 문서의 ENV·API·DDL·잡·캐시 설정만 반영하면 Replit에서 바로 MVP 구동 가능합니다.

운영 중 비용/지연은 캐시 + 큐 + 중복해시로 관리하시고, 템플릿/노드/지표는 위 스키마대로 확장하십시오.



🟢 Replit Zero‑IQ Handoff (한 줄씩 복붙 가이드)

Replit 팀이 그냥 복붙만 해도 돌아가게 만든 초간단 안내입니다. Next.js 없이 Express + EJS로 최소 가동 후, 나중에 React Flow를 붙이는 단계까지 포함했습니다.

0) 새 Repl 만들기

Replit에서 Node.js 템플릿로 새 Repl 생성

좌측 Secrets 탭에 아래 값들 추가

APP_ENV=dev
APP_URL=https://<your-repl>.repl.co
DATABASE_URL=postgres://user:pass@host:5432/db
SESSION_SECRET=change_me
GOOGLE_CLIENT_ID=<from Google Cloud>
GOOGLE_CLIENT_SECRET=<from Google Cloud>
OAUTH_REDIRECT_URI=https://<your-repl>.repl.co/auth/google/callback
OPENAI_API_KEY=sk-...
APIFY_TOKEN=...
INTERNAL_TOKEN=very_long_random
TZ_DEFAULT=Asia/Seoul

1) 설치(터미널에서 한 번만)

npm i express ejs pg passport passport-google-oauth20 express-session multer pdf-parse sharp openai zod p-limit uuid
npm i -D nodemon

Postgres는 Neon/Supabase 연결 문자열을 DATABASE_URL에 넣으시면 됩니다.

2) 프로젝트 구조 만들기

.
├─ index.js            # 서버 시작 파일
├─ views/
│  └─ index.ejs        # 로그인/앱 진입 테스트용
├─ routes/
│  ├─ auth.js
│  ├─ api.js
│  └─ internal.js
├─ lib/
│  ├─ db.js            # pg pool
│  ├─ auth.js          # passport 설정
│  ├─ hash.js          # sha256
│  ├─ openai.js        # OpenAI 클라이언트
│  └─ utils.js
└─ sql/
   └─ schema.sql       # 아래 DDL 복붙 후 실행

3) 최소 서버(index.js)

const express = require('express');
const session = require('express-session');
const passport = require('passport');
const path = require('path');
require('./lib/auth'); // passport 설정 불러오기

const app = express();
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));
app.use(express.json({ limit: '2mb' }));
app.use(express.urlencoded({ extended: true }));
app.use(session({ secret: process.env.SESSION_SECRET, resave: false, saveUninitialized: false }));
app.use(passport.initialize());
app.use(passport.session());

app.get('/', (req, res) => res.render('index', { user: req.user }));
app.use('/auth', require('./routes/auth'));
app.use('/api', require('./routes/api'));
app.use('/internal', require('./routes/internal'));
app.get('/healthz', (req, res)=>res.send('ok'));

const port = process.env.PORT || 3000;
app.listen(port, ()=> console.log('server on', port));

4) Passport 설정(lib/auth.js)

const passport = require('passport');
const { Strategy: GoogleStrategy } = require('passport-google-oauth20');
const { upsertUser, findUserById } = require('./db');

passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: process.env.OAUTH_REDIRECT_URI,
}, async (accessToken, refreshToken, profile, done) => {
  try {
    const user = await upsertUser({
      google_id: profile.id,
      email: profile.emails?.[0]?.value,
      name: profile.displayName,
    });
    done(null, user);
  } catch (e) { done(e); }
}));
passport.serializeUser((user, done)=> done(null, user.id));
passport.deserializeUser(async (id, done)=> {
  try { done(null, await findUserById(id)); } catch(e){ done(e); }
});

module.exports = passport;

5) DB 연결(lib/db.js)

const { Pool } = require('pg');
const pool = new Pool({ connectionString: process.env.DATABASE_URL });

async function upsertUser({ google_id, email, name }){
  const q = `
    INSERT INTO users (google_id, email, name)
    VALUES ($1,$2,$3)
    ON CONFLICT (email) DO UPDATE SET name = EXCLUDED.name
    RETURNING id, email, name;`;
  const { rows } = await pool.query(q, [google_id, email, name]);
  return rows[0];
}
async function findUserById(id){
  const { rows } = await pool.query('SELECT id,email,name FROM users WHERE id=$1', [id]);
  return rows[0];
}
module.exports = { pool, upsertUser, findUserById };

6) 라우트: Auth(routes/auth.js)

const router = require('express').Router();
const passport = require('passport');

router.get('/google', passport.authenticate('google', { scope: ['profile','email'] }));
router.get('/google/callback',
  passport.authenticate('google', { failureRedirect: '/' }),
  (req,res)=>res.redirect('/app'));

module.exports = router;

7) 라우트: API 최소(routes/api.js)

const router = require('express').Router();
function requireAuth(req,res,next){ if(req.isAuthenticated()) return next(); return res.redirect('/'); }

router.get('/me', requireAuth, (req,res)=> res.json({ id:req.user.id, email:req.user.email }));
// 여기에 /api/canvas, /api/assets, /api/templates 등 단계적으로 추가

module.exports = router;

8) 라우트: Internal(routes/internal.js)

const router = require('express').Router();
router.use((req,res,next)=>{
  const ok = req.headers.authorization === `Bearer ${process.env.INTERNAL_TOKEN}`;
  if(!ok) return res.status(401).send('unauthorized');
  next();
});
router.post('/jobs/tick', (req,res)=> res.json({ ok:true }));
module.exports = router;

9) 뷰(views/index.ejs)

<!doctype html>
<html>
  <body>
    <% if (!user) { %>
      <a href="/auth/google">Google 로그인</a>
    <% } else { %>
      <p>로그인: <%= user.email %></p>
      <a href="/api/me">/api/me 테스트</a>
    <% } %>
  </body>
</html>

10) 스키마 적용(sql/schema.sql)

캔버스 상단의 DDL 블록 전체를 복사하여 여기 파일에 붙여넣고, Replit의 Database shell 또는 외부 클라이언트로 실행하세요.

11) 실행 스크립트(package.json)

{
  "scripts": { "start": "node index.js", "dev": "nodemon index.js" }
}

Replit Run 버튼 또는 npm run dev로 실행합니다.

12) 헬스체크 및 로그인 테스트

브라우저에서 https://<your-repl>.repl.co/healthz → ok 보이면 성공

https://<your-repl>.repl.co/ → Google 로그인 → /api/me JSON 확인

13) 다음으로 붙일 것(페이즈2)

템플릿 API: GET /api/templates, POST /api/templates/apply

캔버스 상태 저장: POST /api/canvas/:id/state (flow_json 저장)

OpenAI 피드백: POST /api/canvas/:id/feedback (캐시 검사 후 호출)

자산 인제스트: POST /api/assets (pdf/url) → ingest_jobs 큐 처리

아이콘/노드 패널: node_types/node_instances/node_contents/node_metrics 연결

14) 트러블슈팅(자주 막히는 포인트)

OAuth 리다이렉트 URL 불일치: Google Cloud Console에 정확히 등록(https/도메인 포함)

DB 연결 실패: DATABASE_URL 확인, VPC/IP 제한 해제

OpenAI 401: OPENAI_API_KEY 누락/권한 문제

파일 업로드 오류: multer 파일 크기 제한 늘리기(초기 5~10MB 권장)

시간대: TZ_DEFAULT=Asia/Seoul로 로그/스케줄 일치 확인

여기까지 완료되면, 캔버스 본문 상단의 API/DDL 명세와 1:1 매칭됩니다. 다음 단계에서 React Flow UI와 템플릿 갤러리를 얹으면 완전한 MVP가 됩니다.



📦 템플릿 3종 — JSON 별첨 (Replit 가져오기용)

아래 JSON을 각각 파일로 저장하세요:/templates/tpl_lead_basic_v1.json, /templates/tpl_checkout_basic_v1.json, /templates/tpl_subscription_basic_v1.json

1) tpl_lead_basic_v1.json

{
  "id": "tpl_lead_basic_v1",
  "name": "리드 수집 베이직",
  "version": 1,
  "category": "lead_capture",
  "tags": ["lead", "creator", "email"],
  "parameters": {
    "brand_name": "",
    "lead_magnet_title": "",
    "email_steps": 3
  },
  "best_practices": [
    "히어로 섹션에 명확한 One-liner",
    "폼 필드는 3개 이하",
    "웰컴 이메일은 24h/72h/120h 간격"
  ],
  "flow_json": {
    "nodes": [
      {"id":"n-landing","type":"landing","data":{"title":"{{brand_name}} — 무료 리소스","oneLiner":"{{lead_magnet_title}}","cta":"다운로드"},"position":{"x":0,"y":0}},
      {"id":"n-form","type":"form","data":{"fields":["email","name"],"policy":true},"position":{"x":0,"y":160}},
      {"id":"n-email1","type":"email","data":{"subject":"자료 전달","preview":"다운로드 링크 안내","body_md":"안녕하세요, {{brand_name}} 입니다. 요청하신 리소스를 보내드립니다.","cta":"열람"},"position":{"x":0,"y":320}},
      {"id":"n-email2","type":"email","data":{"subject":"문제-해결 제안","preview":"핵심 혜택 요약","body_md":"당신의 상황에 맞춘 솔루션을 소개합니다.","cta":"상세 보기"},"position":{"x":0,"y":480}}
    ],
    "edges": [
      {"id":"e1","source":"n-landing","target":"n-form"},
      {"id":"e2","source":"n-form","target":"n-email1"},
      {"id":"e3","source":"n-email1","target":"n-email2"}
    ]
  }
}

2) tpl_checkout_basic_v1.json

{
  "id": "tpl_checkout_basic_v1",
  "name": "체크아웃 베이직",
  "version": 1,
  "category": "checkout",
  "tags": ["purchase", "stripe", "offer"],
  "parameters": {
    "brand_name": "",
    "offer_title": "",
    "price_label": "$99"
  },
  "best_practices": [
    "랜딩 첫 화면에 가시적인 CTA",
    "가격/보증/리스크 역전 문구 포함",
    "장바구니 이탈 리마인더 설정"
  ],
  "flow_json": {
    "nodes": [
      {"id":"n-landing","type":"landing","data":{"title":"{{brand_name}} — {{offer_title}}","oneLiner":"핵심 가치 제안","cta":"구매하기"},"position":{"x":0,"y":0}},
      {"id":"n-product","type":"product","data":{"name":"메인 오퍼","price":"{{price_label}}"},"position":{"x":0,"y":160}},
      {"id":"n-checkout","type":"checkout","data":{"provider":"stripe"},"position":{"x":0,"y":320}},
      {"id":"n-thanks","type":"thankyou","data":{"msg":"구매 감사합니다!"},"position":{"x":0,"y":480}},
      {"id":"n-abemail","type":"email","data":{"subject":"장바구니가 남아있어요","preview":"1분이면 결제 완료","body_md":"구매를 마치지 않으셨네요. 지금 이어서 완료해 보세요.","cta":"결제 완료하기"},"position":{"x":240,"y":320}}
    ],
    "edges": [
      {"id":"e1","source":"n-landing","target":"n-product"},
      {"id":"e2","source":"n-product","target":"n-checkout"},
      {"id":"e3","source":"n-checkout","target":"n-thanks"},
      {"id":"e4","source":"n-product","target":"n-abemail","label":"이탈"}
    ]
  }
}

3) tpl_subscription_basic_v1.json

{
  "id": "tpl_subscription_basic_v1",
  "name": "구독 베이직",
  "version": 1,
  "category": "subscription",
  "tags": ["saas", "membership", "stripe"],
  "parameters": {
    "brand_name": "",
    "trial_label": "7일 체험",
    "billing_cycle": "monthly"
  },
  "best_practices": [
    "체험→유료 전환 흐름을 분명히 안내",
    "온보딩 이메일 3단계 구성",
    "갱신/만료 알림 미리 설정"
  ],
  "flow_json": {
    "nodes": [
      {"id":"n-landing","type":"landing","data":{"title":"{{brand_name}} 구독","oneLiner":"지금 시작하고 혜택 받기","cta":"체험 시작"},"position":{"x":0,"y":0}},
      {"id":"n-trial","type":"form","data":{"fields":["email"],"label":"{{trial_label}}"},"position":{"x":0,"y":160}},
      {"id":"n-onboard","type":"email","data":{"subject":"온보딩 1일차","preview":"첫 설정 가이드","body_md":"가장 먼저 해야 할 설정을 안내드립니다.","cta":"첫 설정하기"},"position":{"x":0,"y":320}},
      {"id":"n-billing","type":"subscription","data":{"provider":"stripe","plan":"{{billing_cycle}}"},"position":{"x":0,"y":480}},
      {"id":"n-renew","type":"email","data":{"subject":"갱신 알림","preview":"자동 갱신 예정","body_md":"다음 결제 전 확인하세요.","cta":"계정 관리"},"position":{"x":0,"y":640}}
    ],
    "edges": [
      {"id":"e1","source":"n-landing","target":"n-trial"},
      {"id":"e2","source":"n-trial","target":"n-onboard"},
      {"id":"e3","source":"n-onboard","target":"n-billing"},
      {"id":"e4","source":"n-billing","target":"n-renew"}
    ]
  }
}

적용 방법: 파일 저장 → POST /api/templates로 등록하거나, 관리자 대시보드의 "템플릿 업로드"에서 JSON 업로드 후 Apply 버튼으로 현 캔버스에 fork 적용하십시오.

